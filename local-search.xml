<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>从线程池模型看 Oceanbase 线程池的应用和实现</title>
    <link href="/2024/01/16/thread-pool-learning/"/>
    <url>/2024/01/16/thread-pool-learning/</url>
    
    <content type="html"><![CDATA[<div class="markdown-body">    <h3 id="1-线程池的基本原理和组件"><a href="#1-线程池的基本原理和组件" class="headerlink" title="1. 线程池的基本原理和组件"></a>1. 线程池的基本原理和组件</h3><p>​线程池基本定义：A thread pool maintains multiple threads waiting for tasks to be allocated for concurrent execution by the supervising program. Client can send “work” to the pool and somehow this work gets done without blocking the main thread. It’s efficient because threads are not initialized each time we want the work to be done. Threads are initialized once and remain inactive until some work has to be done. </p><p>三个基本要点：</p><ul><li><p>任务队列</p></li><li><p>线程池调度</p></li><li><p>所有任务结束后唤醒主线程</p></li></ul><p><img src="/img/image-20240113191409986.png" alt="image-20240113191409986"></p><p>一个高质量的C实现线程池：<a href="https://github.com/Pithikos/C-Thread-Pool">https://github.com/Pithikos/C-Thread-Pool</a></p><h5 id="1-1-线程池需要向外提供的必要接口"><a href="#1-1-线程池需要向外提供的必要接口" class="headerlink" title="1.1 线程池需要向外提供的必要接口"></a>1.1 线程池需要向外提供的必要接口</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1.初始化</span><br><span class="hljs-function">threadpool <span class="hljs-title">thpool_init</span><span class="hljs-params">(<span class="hljs-type">int</span> num_threads)</span></span>;<br><br><span class="hljs-comment">// 2.构造job/task，封装成函数调用，压入任务队列</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">thpool_add_work</span><span class="hljs-params">(threadpool, <span class="hljs-type">void</span> (*function_p)(<span class="hljs-type">void</span>*), <span class="hljs-type">void</span>* arg_p)</span></span>;<br><br><span class="hljs-comment">// 3.等待所有任务执行完成，both in queue and currently running</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thpool_wait</span><span class="hljs-params">(threadpool)</span></span>;<br><br><span class="hljs-comment">// 4.暂停所有线程，无论它们处在空闲还是工作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thpool_pause</span><span class="hljs-params">(threadpool)</span></span>;<br><br><span class="hljs-comment">// 5.恢复：从暂停中恢复所以线程原本的工作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thpool_resume</span><span class="hljs-params">(threadpool)</span></span>;<br><br><span class="hljs-comment">// 6.销毁线程池，如果有线程还在运行，等待它工作完毕</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thpool_destroy</span><span class="hljs-params">(threadpool)</span></span>;<br><br><span class="hljs-comment">// 7.返回正在工作的线程数量</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">thpool_num_threads_working</span><span class="hljs-params">(threadpool)</span></span>;<br></code></pre></td></tr></table></figure><h5 id="1-2-用到的数据结构"><a href="#1-2-用到的数据结构" class="headerlink" title="1.2 用到的数据结构"></a>1.2 用到的数据结构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 任务：本质上是一个个由工作函数构成的链表结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">job</span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">job</span>*  prev;<br><span class="hljs-built_in">void</span>   (*function)(<span class="hljs-type">void</span>* arg);<br><span class="hljs-type">void</span>*  arg; <br>&#125; job;<br><br><span class="hljs-comment">// 任务队列：可以通过链表实现，在并发场景下，需要增加读写锁、信号量</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">jobqueue</span>&#123;<br><span class="hljs-type">pthread_mutex_t</span> rwmutex; <br>job  *front;<br>job  *rear;  <br>bsem *has_jobs;<span class="hljs-comment">// 这里设置一个布尔的信号量，用于各个线程等待还是执行</span><br><span class="hljs-type">int</span>   len;<br>&#125; jobqueue;<br><br><span class="hljs-comment">// 线程：基于pthread</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">thread</span>&#123;<br><span class="hljs-type">int</span>       id; <br><span class="hljs-type">pthread_t</span> pthread; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">thpool_</span>* thpool_p;     <br>&#125; thread;<br><br><span class="hljs-comment">// 线程池</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">thpool_</span>&#123;<br>thread**   threads;  <span class="hljs-comment">// 由指针组成的数组</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> num_threads_alive;   <br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> num_threads_working;<br><span class="hljs-type">pthread_mutex_t</span>  thcount_lock; <span class="hljs-comment">// 互斥锁，用于主线程计算线程数</span><br><span class="hljs-type">pthread_cond_t</span>  threads_all_idle;<br>jobqueue  jobqueue; <br>&#125; thpool_;<br></code></pre></td></tr></table></figure><h5 id="1-3-重要接口的内部实现"><a href="#1-3-重要接口的内部实现" class="headerlink" title="1.3 重要接口的内部实现"></a>1.3 重要接口的内部实现</h5><p>线程池部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">thpool_</span>* <span class="hljs-built_in">thpool_init</span>(<span class="hljs-type">int</span> num_threads)&#123;<br>    <span class="hljs-comment">// 1.Make new thread pool</span><br>    <span class="hljs-comment">// 2.Initialise the job queue</span><br>    <span class="hljs-comment">// 3.malloc threads in pool</span><br>    <span class="hljs-comment">// 4.each thread init, 每个线程调用thread_init(..)开始执行</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">thpool_add_work</span><span class="hljs-params">(thpool_* thpool_p, <span class="hljs-type">void</span> (*function_p)(<span class="hljs-type">void</span>*), <span class="hljs-type">void</span>* arg_p)</span></span>&#123;<br>    <span class="hljs-comment">// 1.malloc new job</span><br>    <span class="hljs-comment">// 2.jobqueue_push(job)</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thpool_wait</span><span class="hljs-params">(thpool_* thpool_p)</span></span>&#123;<br>    <span class="hljs-comment">// 1.lock the thcount_lock   </span><br>    <span class="hljs-comment">// 2.若任务队列不为空或有线程正在执行任务，循环等待</span><br>    <span class="hljs-comment">// 同时设置条件变量 threads_all_idle，由于每个线程都会跟踪线程池</span><br>    <span class="hljs-comment">// 只要正在工作的线程数=0，将调用 pthread_cond_signal 通知 thpool_wait</span><br>    <span class="hljs-comment">// 3.unlock the thcount_lock </span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>线程部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">thread_init</span> <span class="hljs-params">(...)</span></span>&#123;<br><span class="hljs-comment">// 1.malloc new thread</span><br>    <span class="hljs-comment">// 2.create the thread, use do_task(args) to finish the work</span><br>    <span class="hljs-built_in">pthread_create</span>(.., .., do_task, args);<br>    <span class="hljs-comment">// 3.detach the child thread and main thread</span><br>    <span class="hljs-built_in">pthread_detach</span>(..)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title">do_task</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread* thread_p)</span></span>&#123;<br>    <span class="hljs-comment">// 1.Register signal handler</span><br>    <span class="hljs-comment">// 2.Mark thread as alive (initialized)</span><br>    lock the thcount_lock, <span class="hljs-keyword">and</span> let num_threads_alive++, unlock<br>    <span class="hljs-comment">// 3.while loop, execute the task</span><br>    lock the thcount_lock, <span class="hljs-keyword">and</span> let num_threads_runnning++, unlock<br>    job* j = <span class="hljs-built_in">jobqueue_pull</span>();<br>    j.<span class="hljs-built_in">func</span>(args);<br>    lock the thcount_lock, <span class="hljs-keyword">and</span> let num_threads_runnning--, unlock<br>   <span class="hljs-comment">// 4. if num_threads_runnning == 0, call the main thread</span><br>    <span class="hljs-comment">// main thread will keep the thpool_wait()</span><br>    <span class="hljs-built_in">pthread_cond_signal</span>(&amp;thpool_p-&gt;threads_all_idle);<br>    <span class="hljs-comment">// 5. Mark thread as finish</span><br>    lock the thcount_lock, <span class="hljs-keyword">and</span> let num_threads_alive--, unlock <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Oceanbase创建线程池并启动任务"><a href="#2-Oceanbase创建线程池并启动任务" class="headerlink" title="2. Oceanbase创建线程池并启动任务"></a>2. Oceanbase创建线程池并启动任务</h3><h4 id="1-使用线程组创建函数注册一个线程池"><a href="#1-使用线程组创建函数注册一个线程池" class="headerlink" title="1. 使用线程组创建函数注册一个线程池"></a>1. 使用线程组创建函数注册一个线程池</h4><p>线程池注册函数：TG_DEF(id, name, type, args…)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">lib::TGDefIDs::id 将参数id传入作用域，获取该id对应的函数编号</span><br><span class="hljs-comment">宏定义的一些语法：A##B：连接AB字符串，#取字符串</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TG_DEF(id, name, type, args...)                 \</span><br><span class="hljs-meta">lib::create_funcs_[lib::TGDefIDs::id] = []() &#123;                     \</span><br><span class="hljs-meta">  auto ret = OB_NEW(TG_##type, SET_USE_500(<span class="hljs-string">&quot;tg&quot;</span>), args); \</span><br>  ret-&gt;attr_ = &#123;<span class="hljs-meta">#name, TGType::type&#125;;        \ </span><br>  <span class="hljs-keyword">return</span> ret;                                                      \<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;share/ob_thread_define.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> TG_DEF</span><br><br><span class="hljs-comment">// type类别</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">TGType</span><br>&#123;<br>  INVALID,<br>  REENTRANT_THREAD_POOL,<br>  THREAD_POOL,<br>  TIMER,<br>  QUEUE_THREAD,<br>  DEDUP_QUEUE,<br>  ASYNC_TASK_QUEUE,<br>  MAP_QUEUE_THREAD<br>&#125;;<br><br><span class="hljs-comment">// 比如注册一个 ParallelDDLPool 线程池</span><br><span class="hljs-built_in">TG_DEF</span>(ParallelDDLPool, ParallelDDLPool, QUEUE_THREAD, <span class="hljs-number">16</span>, <span class="hljs-number">2000</span>)<br></code></pre></td></tr></table></figure><p>为每个注册了的线程池赋予一个系统tg_id： lib::TGDefIDs::{id}</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// #define TG_DEF(id, ...) id, 映射整个TG_DEF() 取其中id</span><br><span class="hljs-comment">// 相当于给各个id赋予一个编号，比如：enum &#123;OB_START=-1, ParallelDDLPool, OB_END&#125;</span><br><span class="hljs-keyword">namespace</span> lib &#123;<br>    <span class="hljs-keyword">namespace</span> TGDefIDs &#123;<br>        <span class="hljs-keyword">enum</span> <span class="hljs-title class_">OBTGDefIDEnum</span><br>        &#123;<br>          OB_START = TGDefIDs::LIB_END - <span class="hljs-number">1</span>,<br>          <span class="hljs-meta">#<span class="hljs-keyword">define</span> TG_DEF(id, ...) id,</span><br>          <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;share/ob_thread_define.h&quot;</span></span><br>          <span class="hljs-meta">#<span class="hljs-keyword">undef</span> TG_DEF</span><br>          OB_END,<br>        &#125;;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="2-创建线程池类（基于-TGRunnable-或-TGTaskHandler-接口）"><a href="#2-创建线程池类（基于-TGRunnable-或-TGTaskHandler-接口）" class="headerlink" title="2. 创建线程池类（基于 TGRunnable 或 TGTaskHandler 接口）"></a>2. 创建线程池类（基于 <em>TGRunnable</em> 或 <em>TGTaskHandler</em> 接口）</h4><ul><li><em>TGRunnable</em>：适合处理无参数允许的任务，比如开启一个定时器等；<ul><li>纯虚函数：<code>virtual void run1() = 0;</code></li></ul></li><li><em>TGTaskHandler</em>：适合处理任何任务<ul><li>纯虚函数：<code>virtual void handle(void *task) = 0;</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObParallelDDLOperator</span> : <span class="hljs-keyword">public</span> lib::TGTaskHandler &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ObParallelDDLOperator</span>();<br>  ~<span class="hljs-built_in">ObParallelDDLOperator</span>();<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(<span class="hljs-type">void</span> *task)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">push_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *task)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> ObParallelDDLOperator &amp;<span class="hljs-title">get_instance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 单例模式</span><br>      <span class="hljs-keyword">return</span> parallel_ddl_;  <br>   &#125;<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> ObArenaAllocator &amp;<span class="hljs-title">get_allocator</span><span class="hljs-params">()</span> </span>&#123; <br>      <span class="hljs-keyword">return</span> parallel_ddl_.allocator_; <br>  &#125; <br>  <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> tg_id_;<br>  <span class="hljs-type">bool</span> is_inited_;<br>  ObArenaAllocator allocator_;<br>  <span class="hljs-type">static</span> ObParallelDDLOperator parallel_ddl_;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="2-1-线程池的初始化"><a href="#2-1-线程池的初始化" class="headerlink" title="2.1 线程池的初始化"></a>2.1 线程池的初始化</h5><p>1、根据已注册线程池的id，生成系统 tg_id，同时映射上 &lt;tg_id，tg_queue_thread*&gt;</p><p>2、将已实现的基于 TGTaskHandler 的 parallel_ddl_ 交给线程池，并调用 tg_queue_thread-&gt;start()；</p><p>3、为方便后面调试线程数量，将线程数解耦放入 global context，可在配置文件中自定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ObParallelDDLOperator::init</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">TG_CREATE</span>(lib::TGDefIDs::ParallelDDLPool, parallel_ddl_.tg_id_);<br>    <span class="hljs-built_in">TG_SET_HANDLER_AND_START</span>(parallel_ddl_.tg_id_, parallel_ddl_);<br>    <span class="hljs-built_in">TG_SET_THREAD_CNT</span>(parallel_ddl_.tg_id_, GCTX.parallel_ddl_thread_num_);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-2-线程池的任务队列接口"><a href="#2-2-线程池的任务队列接口" class="headerlink" title="2.2 线程池的任务队列接口"></a>2.2 线程池的任务队列接口</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ObParallelDDLOperator::push_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *task)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">TG_PUSH_TASK</span>(parallel_ddl_.tg_id_, task);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-3-每个线程完成任务的接口"><a href="#2-3-每个线程完成任务的接口" class="headerlink" title="2.3 每个线程完成任务的接口"></a>2.3 每个线程完成任务的接口</h5><p>具体的任务工作可由task对应类型的实现类的 do_task() 接口完成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ObParallelDDLOperator::handle</span><span class="hljs-params">(<span class="hljs-type">void</span> *task)</span> </span><br><span class="hljs-function"></span>&#123;<br>    ObIDDLOperatorTask *ddl_task = <span class="hljs-built_in">static_cast</span>&lt;ObIDDLOperatorTask*&gt;(task);<br>    <span class="hljs-keyword">if</span> (xxx == ddl_task-&gt;<span class="hljs-built_in">get_type</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> *trans_task = <span class="hljs-built_in">static_cast</span>&lt;ObTransEndDDLOperatorTask*&gt;(ddl_task);<br>        trans_task-&gt;<span class="hljs-built_in">do_task</span>();<br>    &#125;<br>    <span class="hljs-built_in">free</span>(ddl_task);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-定义-Task-基类，实现各类型-Task-需要完成操作的接口"><a href="#3-定义-Task-基类，实现各类型-Task-需要完成操作的接口" class="headerlink" title="3. 定义 Task 基类，实现各类型 Task 需要完成操作的接口"></a>3. 定义 Task 基类，实现各类型 Task 需要完成操作的接口</h4><p>ob决赛中有这样一个小情景：在创建系统租户的过程中，需要完成 1650 张系统表的创建，</p><p>在原本的实现中采用的是一张一张表的创建，效率非常低，因此我们的思路是通过创建若干线程建表，</p><p>在实际的实现过程中，我们发现每张表都在使用事务进行创建，而事务创建和销毁也有开销；</p><p>因此，我们最终的方案是通过 batch create 来实现，每个 batch 由一个事务构成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObIDDLOperatorTask</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ObDDLOperatorTaskType <span class="hljs-title">get_type</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="3-1-实现类"><a href="#3-1-实现类" class="headerlink" title="3.1 实现类"></a>3.1 实现类</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 分批并行执行 create_table</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObCreateTableBatchDDLOperatorTask</span> : <span class="hljs-keyword">public</span> ObDDLOperatorTask &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ObCreateTableBatchDDLOperatorTask</span>(ObDDLService *ddl_service, <span class="hljs-type">uint64_t</span> tenant_id, CallbackFunc callback, ObIArray&lt;ObTableSchema&gt; &amp;schemas, <span class="hljs-type">int64_t</span> begin, <span class="hljs-type">int64_t</span> end);<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ObCreateTableBatchDDLOperatorTask</span>() <span class="hljs-keyword">override</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">do_task</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">do_task</span><span class="hljs-params">(ObDDLSQLTransaction *trans)</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> ObDDLOperatorTaskType <span class="hljs-title">get_type</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>  CallbackFunc callback_;<br>  ObSArray&lt;ObTableSchema&gt; schemas_;<br>  <span class="hljs-type">int64_t</span> begin_;<br>  <span class="hljs-type">int64_t</span> end_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>构造函数：将任务所需的所有参数传入</p><p>回调函数：在这里调用的是下面的主线程原子操作：<em>ObBootstrap</em>::inc_finish_ddl_task_cnt()，目的是每创建一个任务，主线程记录的任务数量 + 1，最后主线程只需通过返回的 get_finish_ddl_task_cnt() 来判断是否继续进行下去。</p><blockquote><p>话说，这里其实可以使用条件变量来实现，不用这么麻烦<del>（之后有时间再说）</del></p></blockquote><p>do_task()：综合各个参数，创建事务，执行建表指令</p><h5 id="3-2-在服务逻辑中构造任务队列，使用线程池"><a href="#3-2-在服务逻辑中构造任务队列，使用线程池" class="headerlink" title="3.2 在服务逻辑中构造任务队列，使用线程池"></a>3.2 在服务逻辑中构造任务队列，使用线程池</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1.单例模式，先获取线程池</span><br>ObParallelDDLOperator &amp;parallel_ddl_operator = ObParallelDDLOperator::<span class="hljs-built_in">get_instance</span>();<br><br><span class="hljs-comment">// 2.划分数据的区间，每个区间构造一个任务，push进线程池</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int64_t</span> i = <span class="hljs-number">0</span>; i &lt; batch_count; ++i) &#123;<br>    <span class="hljs-type">int64_t</span> left = i * batch_size;<br>    <span class="hljs-type">int64_t</span> right = left + batch_size - <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">if</span> (right &gt;= table_schemas.<span class="hljs-built_in">count</span>()) &#123;<br>        right = table_schemas.<span class="hljs-built_in">count</span>()<span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// push the task into thread pool</span><br>    ObDDLOperatorTask *task = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ObCreateTableBatchDDLOperatorTask</span>(&amp;ddl_service, OB_SYS_TENANT_ID, &amp;ObBootstrap::inc_finish_ddl_task_cnt, table_schemas, left, right + <span class="hljs-number">1</span>);<br>    parallel_ddl_operator.<span class="hljs-built_in">push_task</span>(task);<br>    ObBootstrap::<span class="hljs-built_in">inc_start_ddl_task_cnt</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>使用原子操作等待所有任务的执行完毕，主线程才将继续</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 等待所有任务执行完毕</span><br><span class="hljs-type">const</span> <span class="hljs-type">int64_t</span> start_time = ObTimeUtility::<span class="hljs-built_in">current_time</span>();<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">OB_SUCC</span>(ret) &amp;&amp; ObBootstrap::<span class="hljs-built_in">get_finish_ddl_task_cnt</span>() &lt; ObBootstrap::<span class="hljs-built_in">get_start_ddl_task_cnt</span>()) &#123;<br>  <span class="hljs-keyword">if</span> (ObTimeUtility::<span class="hljs-built_in">current_time</span>() - start_time &gt; WAIT_CREATE_SCHEMAS_TIMEOUT_US) &#123;<br>    ret = OB_TIMEOUT;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 几个主线程等待的原子操作</span><br><span class="hljs-type">int64_t</span> ObBootstrap::finish_ddl_task_cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ObBootstrap::inc_finish_ddl_task_cnt</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">ATOMIC_INC</span>(&amp;finish_ddl_task_cnt);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int64_t</span> <span class="hljs-title">ObBootstrap::get_finish_ddl_task_cnt</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ATOMIC_LOAD</span>(&amp;finish_ddl_task_cnt);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-oceanbase线程池的实现原理"><a href="#3-oceanbase线程池的实现原理" class="headerlink" title="3. oceanbase线程池的实现原理"></a>3. oceanbase线程池的实现原理</h3><p>在前面的例子里， 以 <em>tg_queue_thread</em> 为例，从上层向底层探索：</p><p>上层的线程池类型实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1. 使用ITG作为基类，设置基本的接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ITG</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">thread_cnt</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">set_thread_cnt</span><span class="hljs-params">(<span class="hljs-type">int64_t</span>)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">push_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *task)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">set_handler</span><span class="hljs-params">(TGTaskHandler &amp;handler)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">wait_task</span><span class="hljs-params">(<span class="hljs-type">const</span> common::ObTimerTask &amp;task)</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 2.作为一种线程池实现类型，为上层提供接口：set_handler(TGTaskHandler &amp;handler)</span><br><span class="hljs-comment">// 与 TG_THREAD_POOL 的区别在于，后者接口主要服务于无参数的任务：TGRunnable </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TG_QUEUE_THREAD</span> : <span class="hljs-keyword">public</span> ITG<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">TG_QUEUE_THREAD</span>(ThreadCountPair pair, <span class="hljs-type">const</span> <span class="hljs-type">int64_t</span> task_num_limit);<br>  ~<span class="hljs-built_in">TG_QUEUE_THREAD</span>() &#123; <span class="hljs-built_in">destroy</span>(); &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">thread_cnt</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)thread_num_; &#125;<br>    <br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set_handler</span><span class="hljs-params">(TGTaskHandler &amp;handler)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-type">int</span> ret = common::OB_SUCCESS;<br>    <span class="hljs-type">uint64_t</span> tenant_id = <span class="hljs-built_in">get_tenant_id</span>();<br>    <span class="hljs-keyword">if</span> (qth_ != <span class="hljs-literal">nullptr</span>) &#123;<br>      ret = common::OB_ERR_UNEXPECTED;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      qth_ = <span class="hljs-built_in">new</span> (buf_) <span class="hljs-built_in">MySimpleThreadPool</span>();<br>      qth_-&gt;handler_ = &amp;handler;<br>      qth_-&gt;<span class="hljs-built_in">set_run_wrapper</span>(tg_helper_);<br>      ret = qth_-&gt;<span class="hljs-built_in">init</span>(thread_num_, task_num_limit_, attr_.name_, tenant_id);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br>    <br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-type">int</span> ret = common::OB_SUCCESS;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br>    <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> (qth_ != <span class="hljs-literal">nullptr</span>) &#123;<br>      qth_-&gt;<span class="hljs-built_in">wait</span>();<br>      <span class="hljs-built_in">destroy</span>();<br>    &#125;<br>  &#125;<br>    <br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">push_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *task)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-type">int</span> ret = common::OB_SUCCESS;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_ISNULL</span>(qth_)) &#123;<br>      ret = common::OB_ERR_UNEXPECTED;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ret = qth_-&gt;<span class="hljs-built_in">push</span>(task);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> buf_[<span class="hljs-built_in">sizeof</span>(MySimpleThreadPool)];<br>  MySimpleThreadPool *qth_ = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">// 继承自 ObSimpleThreadPool</span><br>  <span class="hljs-type">int64_t</span> thread_num_;<br>  <span class="hljs-type">int64_t</span> task_num_limit_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>继续往下分析，ObSimpleThreadPool 是整个ob线程池实现模型的核心环节</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">init：初始化元数据，开启线程池；</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ObSimpleThreadPool::init</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function"></span>&#123;<br>    queue_.<span class="hljs-built_in">init</span>(task_num_limit, name, tenant_id);<br>    <span class="hljs-built_in">set_thread_count</span>(thread_num);<br>    lib::ThreadPool::<span class="hljs-built_in">start</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ObSimpleThreadPool::run1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    使用 ObAdaptiveStrategy 策略，并使用 ATOMIC_STORE 原子存储 total_thread_num_ 和 active_thread_num_；</span><br><span class="hljs-comment">    如果当前有线程空闲，对任务队列执行pop操作，用上层传入的handler执行这个任务；</span><br><span class="hljs-comment">    比如：ObParallelDDLOperator有用户实现的自定义handler，执行具体的任务。</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>继续往下，分析线程池中线程的调度：</p><p>每个线程其实封装了worker，在当前线程的生命周期内，可以通过线程本地存储TLS获取到这个worker对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Threads::start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 1.在检查租户上下文完备后，内存分配一个 threads_ 动态数组</span><br>    <span class="hljs-comment">// 2.每一个thread使用 Threads::create_thread -&gt; Thread::start()</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Threads::run</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> idx)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">ObTLTaGuard <span class="hljs-title">ta_guard</span><span class="hljs-params">(GET_TENANT_ID() ?:OB_SERVER_TENANT_ID)</span></span>;<br>  thread_idx_ = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(idx);<br>  Worker worker;<br>  Worker::<span class="hljs-built_in">set_worker_to_thread_local</span>(&amp;worker);<br>  <span class="hljs-built_in">run1</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>最底层线程的实现，本质就是调用 POSIX 中关于 pthread 的各类接口，并做一定的封装</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">pthread_create(</span><br><span class="hljs-comment">pthread_t pointer, </span><br><span class="hljs-comment">attr of new thread,</span><br><span class="hljs-comment">the main execute function pointer,</span><br><span class="hljs-comment">args which will send to main function)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Thread::start</span><span class="hljs-params">()</span> </span>&#123;<br>    pret = <span class="hljs-built_in">pthread_create</span>(&amp;pth_, &amp;attr, __th_start, <span class="hljs-keyword">this</span>);<br>    <span class="hljs-built_in">ATOMIC_FAA</span>(&amp;total_thread_count_, <span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::dump_pth</span><span class="hljs-params">()</span> <span class="hljs-comment">// 可以用于 debug pthread join failed</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::wait</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">pthread_join</span>(pth_, <span class="hljs-literal">nullptr</span>);<br>&#125;<br><br><span class="hljs-type">void</span>* Thread::__th_start(<span class="hljs-type">void</span> *arg) &#123;<br>    <span class="hljs-comment">// 主要工作：设置线程上下文、元数据，并调用 th-&gt;run(); 执行 Threads::run</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-复习："><a href="#4-复习：" class="headerlink" title="4. 复习："></a>4. 复习：</h3><h5 id="4-1-条件变量-condition-variable"><a href="#4-1-条件变量-condition-variable" class="headerlink" title="4.1 条件变量 condition variable"></a>4.1 条件变量 condition variable</h5><p>作用：条件变量通过将等待线程挂起，直到条件满足主线程才继续，而不是通过一直循环检查条件，从而可以有效避免忙等，节省 CPU 资源。</p><p>1、多线程中用于线程间同步与通信的一种机制；</p><p>2、允许一个线程A休眠，直到等待另一个线程B满足特定条件时，A才再继续执行。</p><p>3、在不用条件变量时，线程A等待线程B满足一个条件C时，若C迟迟不能满足，A将一直使用CPU资源进行轮询，直到看到满足条件C时，不再轮询，A继续执行：这导致空耗CPU资源。</p><h5 id="4-2-信号量"><a href="#4-2-信号量" class="headerlink" title="4.2 信号量"></a>4.2 信号量</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* Binary semaphore */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">bsem</span> &#123;<br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><span class="hljs-type">pthread_cond_t</span>   cond;<br><span class="hljs-type">int</span> v;<br>&#125; bsem;<br></code></pre></td></tr></table></figure><p>基本操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>  <span class="hljs-title">bsem_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bsem *bsem_p, <span class="hljs-type">int</span> value)</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>  <span class="hljs-title">bsem_reset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bsem *bsem_p)</span></span>;<br><br><span class="hljs-comment">// V操作：设置信号量为1，通知其他线程，有资源可用</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>  <span class="hljs-title">bsem_post</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bsem *bsem_p)</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>  <span class="hljs-title">bsem_post_all</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bsem *bsem_p)</span></span>;<br><br><span class="hljs-comment">// P操作：如果信号量为 1，表示资源可用，线程将 v=v-1，继续执行</span><br><span class="hljs-comment">// 如果为 0，表示资源不可用，线程阻塞等待条件变量</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>  <span class="hljs-title">bsem_wait</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bsem *bsem_p)</span></span>;<br></code></pre></td></tr></table></figure><p>Reference：</p><p>[1] <a href="https://github.com/mtrebi/thread-pool">https://github.com/mtrebi/thread-pool</a></p><p>[2] <a href="https://github.com/Pithikos/C-Thread-Pool">https://github.com/Pithikos/C-Thread-Pool</a></p><p>[3] <a href="https://open.oceanbase.com/train?questionId=600006">https://open.oceanbase.com/train?questionId=600006</a>    </p></div>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
